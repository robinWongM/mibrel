package nixpacks

/*


// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

#include <stdbool.h>
#include <stdint.h>

// The following structs are used to implement the lowest level
// of the FFI, and thus useful to multiple uniffied crates.
// We ensure they are declared exactly once, with a header guard, UNIFFI_SHARED_H.
#ifdef UNIFFI_SHARED_H
	// We also try to prevent mixing versions of shared uniffi header structs.
	// If you add anything to the #else block, you must increment the version suffix in UNIFFI_SHARED_HEADER_V4
	#ifndef UNIFFI_SHARED_HEADER_V4
		#error Combining helper code from multiple versions of uniffi is not supported
	#endif // ndef UNIFFI_SHARED_HEADER_V4
#else
#define UNIFFI_SHARED_H
#define UNIFFI_SHARED_HEADER_V4
// ⚠️ Attention: If you change this #else block (ending in `#endif // def UNIFFI_SHARED_H`) you *must* ⚠️
// ⚠️ increment the version suffix in all instances of UNIFFI_SHARED_HEADER_V4 in this file.           ⚠️

typedef struct RustBuffer {
	int32_t capacity;
	int32_t len;
	uint8_t *data;
} RustBuffer;

typedef int32_t (*ForeignCallback)(uint64_t, int32_t, RustBuffer, RustBuffer *);

typedef struct ForeignBytes {
	int32_t len;
	const uint8_t *data;
} ForeignBytes;

// Error definitions
typedef struct RustCallStatus {
	int8_t code;
	RustBuffer errorBuf;
} RustCallStatus;

// ⚠️ Attention: If you change this #else block (ending in `#endif // def UNIFFI_SHARED_H`) you *must* ⚠️
// ⚠️ increment the version suffix in all instances of UNIFFI_SHARED_HEADER_V4 in this file.           ⚠️
#endif // def UNIFFI_SHARED_H

RustBuffer nixpacks_e158_get_plan_providers(
	RustBuffer path,
	RustBuffer envs,
	RustCallStatus* out_status
);

RustBuffer nixpacks_e158_generate_build_plan(
	RustBuffer path,
	RustBuffer envs,
	RustCallStatus* out_status
);

RustBuffer ffi_nixpacks_e158_rustbuffer_alloc(
	int32_t size,
	RustCallStatus* out_status
);

RustBuffer ffi_nixpacks_e158_rustbuffer_from_bytes(
	ForeignBytes bytes,
	RustCallStatus* out_status
);

void ffi_nixpacks_e158_rustbuffer_free(
	RustBuffer buf,
	RustCallStatus* out_status
);

RustBuffer ffi_nixpacks_e158_rustbuffer_reserve(
	RustBuffer buf,
	int32_t additional,
	RustCallStatus* out_status
);


*/
import "C"

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"unsafe"
)

type rustBuffer struct {
	capacity int
	length   int
	data     unsafe.Pointer
	self     C.RustBuffer
}

func fromCRustBuffer(crbuf C.RustBuffer) rustBuffer {
	return rustBuffer{
		capacity: int(crbuf.capacity),
		length:   int(crbuf.len),
		data:     unsafe.Pointer(crbuf.data),
		self:     crbuf,
	}
}

// asByteBuffer reads the full rust buffer and then converts read bytes to a new reader which makes
// it quite inefficient
// TODO: Return an implementation which reads only when needed
func (rb rustBuffer) asReader() *bytes.Reader {
	b := C.GoBytes(rb.data, C.int(rb.length))
	return bytes.NewReader(b)
}

func (rb rustBuffer) asCRustBuffer() C.RustBuffer {
	return C.RustBuffer{
		capacity: C.int(rb.capacity),
		len:      C.int(rb.length),
		data:     (*C.uchar)(unsafe.Pointer(rb.data)),
	}
}

func stringToCRustBuffer(str string) C.RustBuffer {
	b := []byte(str)
	cs := C.CString(str)
	return C.RustBuffer{
		capacity: C.int(len(b)),
		len:      C.int(len(b)),
		data:     (*C.uchar)(unsafe.Pointer(cs)),
	}
}

func (rb rustBuffer) free() {
	rustCall(func(status *C.RustCallStatus) bool {
		C.ffi_nixpacks_e158_rustbuffer_free(rb.self, status)
		return false
	})
}

type bufLifter[GoType any] interface {
	lift(value C.RustBuffer) GoType
}

type bufLowerer[GoType any] interface {
	lower(value GoType) C.RustBuffer
}

type ffiConverter[GoType any, FfiType any] interface {
	lift(value FfiType) GoType
	lower(value GoType) FfiType
}

type bufReader[GoType any] interface {
	read(reader io.Reader) GoType
}

type bufWriter[GoType any] interface {
	write(writer io.Writer, value GoType)
}

type ffiRustBufConverter[GoType any, FfiType any] interface {
	ffiConverter[GoType, FfiType]
	bufReader[GoType]
}

func lowerIntoRustBuffer[GoType any](bufWriter bufWriter[GoType], value GoType) C.RustBuffer {
	// This might be not the most efficient way but it does not require knowing allocation size
	// beforehand
	var buffer bytes.Buffer
	bufWriter.write(&buffer, value)

	bytes, err := io.ReadAll(&buffer)
	if err != nil {
		panic(fmt.Errorf("reading written data: %w", err))
	}

	return stringToCRustBuffer(string(bytes))
}

func liftFromRustBuffer[GoType any](bufReader bufReader[GoType], rbuf rustBuffer) GoType {
	defer rbuf.free()
	reader := rbuf.asReader()
	item := bufReader.read(reader)
	if reader.Len() > 0 {
		// TODO: Remove this
		leftover, _ := io.ReadAll(reader)
		panic(fmt.Errorf("Junk remaining in buffer after lifting: %s", string(leftover)))
	}
	return item
}

func rustCallWithError[U any](converter bufLifter[error], callback func(*C.RustCallStatus) U) (U, error) {
	var status C.RustCallStatus
	returnValue := callback(&status)
	switch status.code {
	case 0:
		return returnValue, nil
	case 1:
		return returnValue, converter.lift(status.errorBuf)
	case 2:
		// when the rust code sees a panic, it tries to construct a rustbuffer
		// with the message.  but if that code panics, then it just sends back
		// an empty buffer.
		if status.errorBuf.len > 0 {
			panic(fmt.Errorf("%s", FfiConverterstringINSTANCE.lift(status.errorBuf)))
		} else {
			panic(fmt.Errorf("Rust panicked while handling Rust panic"))
		}
	default:
		return returnValue, fmt.Errorf("unknown status code: %d", status.code)
	}
}

func rustCall[U any](callback func(*C.RustCallStatus) U) U {
	returnValue, err := rustCallWithError(nil, callback)
	if err != nil {
		panic(err)
	}
	return returnValue
}

func writeInt8(writer io.Writer, value int8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint8(writer io.Writer, value uint8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt16(writer io.Writer, value int16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint16(writer io.Writer, value uint16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt32(writer io.Writer, value int32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint32(writer io.Writer, value uint32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt64(writer io.Writer, value int64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint64(writer io.Writer, value uint64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat32(writer io.Writer, value float32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat64(writer io.Writer, value float64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func readInt8(reader io.Reader) int8 {
	var result int8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint8(reader io.Reader) uint8 {
	var result uint8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt16(reader io.Reader) int16 {
	var result int16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint16(reader io.Reader) uint16 {
	var result uint16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt32(reader io.Reader) int32 {
	var result int32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint32(reader io.Reader) uint32 {
	var result uint32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt64(reader io.Reader) int64 {
	var result int64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint64(reader io.Reader) uint64 {
	var result uint64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat32(reader io.Reader) float32 {
	var result float32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat64(reader io.Reader) float64 {
	var result float64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func init() {

}

type FfiConverterstring struct{}

var FfiConverterstringINSTANCE = FfiConverterstring{}

func (FfiConverterstring) lift(cRustBuf C.RustBuffer) string {
	reader := fromCRustBuffer(cRustBuf).asReader()
	b, err := io.ReadAll(reader)
	if err != nil {
		panic(fmt.Errorf("reading reader: %w", err))
	}
	return string(b)
}

func (FfiConverterstring) read(reader io.Reader) string {
	length := readInt32(reader)
	buffer := make([]byte, length)
	read_length, err := reader.Read(buffer)
	if err != nil {
		panic(err)
	}
	if read_length != int(length) {
		panic(fmt.Errorf("bad read length when reading string, expected %d, read %d", length, read_length))
	}
	return string(buffer)
}

func (FfiConverterstring) lower(value string) C.RustBuffer {
	return stringToCRustBuffer(value)
}

func (FfiConverterstring) write(writer io.Writer, value string) {
	if len(value) > math.MaxInt32 {
		panic("String is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	write_length, err := io.WriteString(writer, value)
	if err != nil {
		panic(err)
	}
	if write_length != len(value) {
		panic(fmt.Errorf("bad write length when writing string, expected %d, written %d", len(value), write_length))
	}
}

type FfiDestroyerstring struct{}

func (FfiDestroyerstring) destroy(_ string) {}

type BuildPlanWithHashMap struct {
	Providers    *[]string
	BuildImage   *string
	Variables    *BTreeMapSS
	StaticAssets *BTreeMapSS
	Phases       *map[string]Phase
	StartPhase   *StartPhase
}

func (r *BuildPlanWithHashMap) Destroy() {
	FfiDestroyerOptionalSequencestring{}.destroy(r.Providers)
	FfiDestroyerOptionalstring{}.destroy(r.BuildImage)
	FfiDestroyerOptionalTypeBTreeMapSs{}.destroy(r.Variables)
	FfiDestroyerOptionalTypeBTreeMapSs{}.destroy(r.StaticAssets)
	FfiDestroyerOptionalMapstringPhase{}.destroy(r.Phases)
	FfiDestroyerOptionalTypeStartPhase{}.destroy(r.StartPhase)
}

type FfiConverterTypeBuildPlanWithHashMap struct{}

var FfiConverterTypeBuildPlanWithHashMapINSTANCE = FfiConverterTypeBuildPlanWithHashMap{}

func (c FfiConverterTypeBuildPlanWithHashMap) lift(cRustBuf C.RustBuffer) BuildPlanWithHashMap {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[BuildPlanWithHashMap](c, rustBuffer)
}

func (c FfiConverterTypeBuildPlanWithHashMap) read(reader io.Reader) BuildPlanWithHashMap {
	return BuildPlanWithHashMap{
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalstringINSTANCE.read(reader),
		FfiConverterOptionalTypeBTreeMapSsINSTANCE.read(reader),
		FfiConverterOptionalTypeBTreeMapSsINSTANCE.read(reader),
		FfiConverterOptionalMapstringPhaseINSTANCE.read(reader),
		FfiConverterOptionalTypeStartPhaseINSTANCE.read(reader),
	}
}

func (c FfiConverterTypeBuildPlanWithHashMap) lower(value BuildPlanWithHashMap) C.RustBuffer {
	return lowerIntoRustBuffer[BuildPlanWithHashMap](c, value)
}

func (c FfiConverterTypeBuildPlanWithHashMap) write(writer io.Writer, value BuildPlanWithHashMap) {
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.Providers)
	FfiConverterOptionalstringINSTANCE.write(writer, value.BuildImage)
	FfiConverterOptionalTypeBTreeMapSsINSTANCE.write(writer, value.Variables)
	FfiConverterOptionalTypeBTreeMapSsINSTANCE.write(writer, value.StaticAssets)
	FfiConverterOptionalMapstringPhaseINSTANCE.write(writer, value.Phases)
	FfiConverterOptionalTypeStartPhaseINSTANCE.write(writer, value.StartPhase)
}

type FfiDestroyerTypeBuildPlanWithHashMap struct{}

func (_ FfiDestroyerTypeBuildPlanWithHashMap) destroy(value BuildPlanWithHashMap) {
	value.Destroy()
}

type Phase struct {
	Name             *string
	DependsOn        *[]string
	NixPkgs          *[]string
	NixLibs          *[]string
	NixOverlays      *[]string
	NixpkgsArchive   *string
	AptPkgs          *[]string
	Cmds             *[]string
	OnlyIncludeFiles *[]string
	CacheDirectories *[]string
	Paths            *[]string
}

func (r *Phase) Destroy() {
	FfiDestroyerOptionalstring{}.destroy(r.Name)
	FfiDestroyerOptionalSequencestring{}.destroy(r.DependsOn)
	FfiDestroyerOptionalSequencestring{}.destroy(r.NixPkgs)
	FfiDestroyerOptionalSequencestring{}.destroy(r.NixLibs)
	FfiDestroyerOptionalSequencestring{}.destroy(r.NixOverlays)
	FfiDestroyerOptionalstring{}.destroy(r.NixpkgsArchive)
	FfiDestroyerOptionalSequencestring{}.destroy(r.AptPkgs)
	FfiDestroyerOptionalSequencestring{}.destroy(r.Cmds)
	FfiDestroyerOptionalSequencestring{}.destroy(r.OnlyIncludeFiles)
	FfiDestroyerOptionalSequencestring{}.destroy(r.CacheDirectories)
	FfiDestroyerOptionalSequencestring{}.destroy(r.Paths)
}

type FfiConverterTypePhase struct{}

var FfiConverterTypePhaseINSTANCE = FfiConverterTypePhase{}

func (c FfiConverterTypePhase) lift(cRustBuf C.RustBuffer) Phase {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[Phase](c, rustBuffer)
}

func (c FfiConverterTypePhase) read(reader io.Reader) Phase {
	return Phase{
		FfiConverterOptionalstringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalstringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
	}
}

func (c FfiConverterTypePhase) lower(value Phase) C.RustBuffer {
	return lowerIntoRustBuffer[Phase](c, value)
}

func (c FfiConverterTypePhase) write(writer io.Writer, value Phase) {
	FfiConverterOptionalstringINSTANCE.write(writer, value.Name)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.DependsOn)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.NixPkgs)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.NixLibs)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.NixOverlays)
	FfiConverterOptionalstringINSTANCE.write(writer, value.NixpkgsArchive)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.AptPkgs)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.Cmds)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.OnlyIncludeFiles)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.CacheDirectories)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.Paths)
}

type FfiDestroyerTypePhase struct{}

func (_ FfiDestroyerTypePhase) destroy(value Phase) {
	value.Destroy()
}

type StartPhase struct {
	Cmd              *string
	RunImage         *string
	OnlyIncludeFiles *[]string
}

func (r *StartPhase) Destroy() {
	FfiDestroyerOptionalstring{}.destroy(r.Cmd)
	FfiDestroyerOptionalstring{}.destroy(r.RunImage)
	FfiDestroyerOptionalSequencestring{}.destroy(r.OnlyIncludeFiles)
}

type FfiConverterTypeStartPhase struct{}

var FfiConverterTypeStartPhaseINSTANCE = FfiConverterTypeStartPhase{}

func (c FfiConverterTypeStartPhase) lift(cRustBuf C.RustBuffer) StartPhase {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[StartPhase](c, rustBuffer)
}

func (c FfiConverterTypeStartPhase) read(reader io.Reader) StartPhase {
	return StartPhase{
		FfiConverterOptionalstringINSTANCE.read(reader),
		FfiConverterOptionalstringINSTANCE.read(reader),
		FfiConverterOptionalSequencestringINSTANCE.read(reader),
	}
}

func (c FfiConverterTypeStartPhase) lower(value StartPhase) C.RustBuffer {
	return lowerIntoRustBuffer[StartPhase](c, value)
}

func (c FfiConverterTypeStartPhase) write(writer io.Writer, value StartPhase) {
	FfiConverterOptionalstringINSTANCE.write(writer, value.Cmd)
	FfiConverterOptionalstringINSTANCE.write(writer, value.RunImage)
	FfiConverterOptionalSequencestringINSTANCE.write(writer, value.OnlyIncludeFiles)
}

type FfiDestroyerTypeStartPhase struct{}

func (_ FfiDestroyerTypeStartPhase) destroy(value StartPhase) {
	value.Destroy()
}

type FfiConverterOptionalstring struct{}

var FfiConverterOptionalstringINSTANCE = FfiConverterOptionalstring{}

func (c FfiConverterOptionalstring) lift(cRustBuf C.RustBuffer) *string {
	return liftFromRustBuffer[*string](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalstring) read(reader io.Reader) *string {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterstringINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalstring) lower(value *string) C.RustBuffer {
	return lowerIntoRustBuffer[*string](c, value)
}

func (_ FfiConverterOptionalstring) write(writer io.Writer, value *string) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterstringINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalstring struct{}

func (_ FfiDestroyerOptionalstring) destroy(value *string) {
	if value != nil {
		FfiDestroyerstring{}.destroy(*value)
	}
}

type FfiConverterOptionalTypeStartPhase struct{}

var FfiConverterOptionalTypeStartPhaseINSTANCE = FfiConverterOptionalTypeStartPhase{}

func (c FfiConverterOptionalTypeStartPhase) lift(cRustBuf C.RustBuffer) *StartPhase {
	return liftFromRustBuffer[*StartPhase](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalTypeStartPhase) read(reader io.Reader) *StartPhase {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeStartPhaseINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeStartPhase) lower(value *StartPhase) C.RustBuffer {
	return lowerIntoRustBuffer[*StartPhase](c, value)
}

func (_ FfiConverterOptionalTypeStartPhase) write(writer io.Writer, value *StartPhase) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeStartPhaseINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeStartPhase struct{}

func (_ FfiDestroyerOptionalTypeStartPhase) destroy(value *StartPhase) {
	if value != nil {
		FfiDestroyerTypeStartPhase{}.destroy(*value)
	}
}

type FfiConverterOptionalSequencestring struct{}

var FfiConverterOptionalSequencestringINSTANCE = FfiConverterOptionalSequencestring{}

func (c FfiConverterOptionalSequencestring) lift(cRustBuf C.RustBuffer) *[]string {
	return liftFromRustBuffer[*[]string](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalSequencestring) read(reader io.Reader) *[]string {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequencestringINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalSequencestring) lower(value *[]string) C.RustBuffer {
	return lowerIntoRustBuffer[*[]string](c, value)
}

func (_ FfiConverterOptionalSequencestring) write(writer io.Writer, value *[]string) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequencestringINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalSequencestring struct{}

func (_ FfiDestroyerOptionalSequencestring) destroy(value *[]string) {
	if value != nil {
		FfiDestroyerSequencestring{}.destroy(*value)
	}
}

type FfiConverterOptionalMapstringPhase struct{}

var FfiConverterOptionalMapstringPhaseINSTANCE = FfiConverterOptionalMapstringPhase{}

func (c FfiConverterOptionalMapstringPhase) lift(cRustBuf C.RustBuffer) *map[string]Phase {
	return liftFromRustBuffer[*map[string]Phase](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalMapstringPhase) read(reader io.Reader) *map[string]Phase {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMapstringPhaseINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalMapstringPhase) lower(value *map[string]Phase) C.RustBuffer {
	return lowerIntoRustBuffer[*map[string]Phase](c, value)
}

func (_ FfiConverterOptionalMapstringPhase) write(writer io.Writer, value *map[string]Phase) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMapstringPhaseINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalMapstringPhase struct{}

func (_ FfiDestroyerOptionalMapstringPhase) destroy(value *map[string]Phase) {
	if value != nil {
		FfiDestroyerMapstringPhase{}.destroy(*value)
	}
}

type FfiConverterOptionalTypeBTreeMapSs struct{}

var FfiConverterOptionalTypeBTreeMapSsINSTANCE = FfiConverterOptionalTypeBTreeMapSs{}

func (c FfiConverterOptionalTypeBTreeMapSs) lift(cRustBuf C.RustBuffer) *BTreeMapSS {
	return liftFromRustBuffer[*BTreeMapSS](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalTypeBTreeMapSs) read(reader io.Reader) *BTreeMapSS {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeBTreeMapSsINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeBTreeMapSs) lower(value *BTreeMapSS) C.RustBuffer {
	return lowerIntoRustBuffer[*BTreeMapSS](c, value)
}

func (_ FfiConverterOptionalTypeBTreeMapSs) write(writer io.Writer, value *BTreeMapSS) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeBTreeMapSsINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeBTreeMapSs struct{}

func (_ FfiDestroyerOptionalTypeBTreeMapSs) destroy(value *BTreeMapSS) {
	if value != nil {
		FfiDestroyerTypeBTreeMapSs{}.destroy(*value)
	}
}

type FfiConverterSequencestring struct{}

var FfiConverterSequencestringINSTANCE = FfiConverterSequencestring{}

func (c FfiConverterSequencestring) lift(cRustBuf C.RustBuffer) []string {
	return liftFromRustBuffer[[]string](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterSequencestring) read(reader io.Reader) []string {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]string, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterstringINSTANCE.read(reader))
	}
	return result
}

func (c FfiConverterSequencestring) lower(value []string) C.RustBuffer {
	return lowerIntoRustBuffer[[]string](c, value)
}

func (c FfiConverterSequencestring) write(writer io.Writer, value []string) {
	if len(value) > math.MaxInt32 {
		panic("[]string is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterstringINSTANCE.write(writer, item)
	}
}

type FfiDestroyerSequencestring struct{}

func (FfiDestroyerSequencestring) destroy(sequence []string) {
	for _, value := range sequence {
		FfiDestroyerstring{}.destroy(value)
	}
}

type FfiConverterMapstringstring struct{}

var FfiConverterMapstringstringINSTANCE = FfiConverterMapstringstring{}

func (c FfiConverterMapstringstring) lift(cRustBuf C.RustBuffer) map[string]string {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[map[string]string](c, rustBuffer)
}

func (_ FfiConverterMapstringstring) read(reader io.Reader) map[string]string {
	result := make(map[string]string)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterstringINSTANCE.read(reader)
		value := FfiConverterstringINSTANCE.read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapstringstring) lower(value map[string]string) C.RustBuffer {
	return lowerIntoRustBuffer[map[string]string](c, value)
}

func (_ FfiConverterMapstringstring) write(writer io.Writer, mapValue map[string]string) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string]string is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterstringINSTANCE.write(writer, key)
		FfiConverterstringINSTANCE.write(writer, value)
	}
}

type FfiDestroyerMapstringstring struct{}

func (_ FfiDestroyerMapstringstring) destroy(mapValue map[string]string) {
	for key, value := range mapValue {
		FfiDestroyerstring{}.destroy(key)
		FfiDestroyerstring{}.destroy(value)
	}
}

type FfiConverterMapstringPhase struct{}

var FfiConverterMapstringPhaseINSTANCE = FfiConverterMapstringPhase{}

func (c FfiConverterMapstringPhase) lift(cRustBuf C.RustBuffer) map[string]Phase {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[map[string]Phase](c, rustBuffer)
}

func (_ FfiConverterMapstringPhase) read(reader io.Reader) map[string]Phase {
	result := make(map[string]Phase)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterstringINSTANCE.read(reader)
		value := FfiConverterTypePhaseINSTANCE.read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapstringPhase) lower(value map[string]Phase) C.RustBuffer {
	return lowerIntoRustBuffer[map[string]Phase](c, value)
}

func (_ FfiConverterMapstringPhase) write(writer io.Writer, mapValue map[string]Phase) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string]Phase is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterstringINSTANCE.write(writer, key)
		FfiConverterTypePhaseINSTANCE.write(writer, value)
	}
}

type FfiDestroyerMapstringPhase struct{}

func (_ FfiDestroyerMapstringPhase) destroy(mapValue map[string]Phase) {
	for key, value := range mapValue {
		FfiDestroyerstring{}.destroy(key)
		FfiDestroyerTypePhase{}.destroy(value)
	}
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type BTreeMapSS = map[string]string
type FfiConverterTypeBTreeMapSs = FfiConverterMapstringstring
type FfiDestroyerTypeBTreeMapSs = FfiDestroyerMapstringstring

var FfiConverterTypeBTreeMapSsINSTANCE = FfiConverterMapstringstring{}

func GetPlanProviders(path string, envs []string) []string {

	return FfiConverterSequencestringINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.nixpacks_e158_get_plan_providers(FfiConverterstringINSTANCE.lower(path), FfiConverterSequencestringINSTANCE.lower(envs), _uniffiStatus)
	}))

}

func GenerateBuildPlan(path string, envs []string) BuildPlanWithHashMap {

	return FfiConverterTypeBuildPlanWithHashMapINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.nixpacks_e158_generate_build_plan(FfiConverterstringINSTANCE.lower(path), FfiConverterSequencestringINSTANCE.lower(envs), _uniffiStatus)
	}))

}
